<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML>
<HEAD>
<TITLE>
Grammar
</TITLE>
</HEAD>
<FONT SIZE="+2"><B>Grammar</B></FONT><BR><BR><HR>
<FONT SIZE="+1"><B>Overview</B></FONT><BR>
<P>
No Documentation Specified
<BR><HR>
<B>Owner</B>
<A HREF="../../../../Root/XML/Parser/index.html">Parser</A>
<BR><HR>
<B>Parents</B>
<A HREF="../../../../Root/XCore/NamedElement/index.html">NamedElement</A>
,<A HREF="../../../../Root/XOCL/Syntax/index.html">Syntax</A>
<BR><HR>
<B>Subclasses</B>
<BR><HR><BR>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Constructors</B></FONT></TD>
</TR>
<TR><TD>Grammar(name,imports)</TD><TD> No Documentation </TD></TR>
<TR><TD>Grammar(name,imports,clauses)</TD><TD> No Documentation </TD></TR>
</TABLE>
<BR><HR><BR>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=3><FONT SIZE="+2">
<B>Attributes</B></FONT></TD>
</TR>
<TR><TD><B>cache</B></TD><TD><A HREF="../../../../Root/XCore/Table/index.html">Table<A></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B>clauses</B></TD><TD><A HREF="../../../../Root/XML/Parser/Clause/index.html">Seq(Clause)<A></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B>debug</B></TD><TD><A HREF="../../../../Root/XCore/Boolean/index.html">Boolean<A></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B>imports</B></TD><TD><A HREF="../../../../Root/XOCL/NameSpace/index.html">Seq(NameSpace)<A></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B>parents</B></TD><TD><A HREF="../../../../Root/XML/Parser/Grammar/index.html">Seq(Grammar)<A></TD><TD>No Documentation Specified</TD></TR>
<TR>
<TD COLSPAN=3>
<FONT SIZE="-1">
<B>From</B> <A HREF="../../../../Root/XCore/NamedElement/index.html">NamedElement</A>: name. <BR><B>From</B> <A HREF="../../../../Root/XCore/Contained/index.html">Contained</A>: owner. <BR><B>From</B> <A HREF="../../../../Root/XCore/Performable/index.html">Performable</A>: endLine, line. <BR><B>From</B> <A HREF="../../../../Root/XCore/Located/index.html">Located</A>: charEnd, charStart. <BR></FONT>
</TD>
</TR>
</TABLE>
<BR><HR><BR>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="2" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Operations</B></FONT></TD>
</TR>
<TR><TD><B>BNF():<A HREF="../../../../Root/XML/Parser/Grammar/index.html">Grammar<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B>CNF():<A HREF="../../../../Root/XML/Parser/Grammar/index.html">Grammar<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B>NNF():<A HREF="../../../../Root/XML/Parser/Grammar/index.html">Grammar<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B>ONF():<A HREF="../../../../Root/XML/Parser/Grammar/index.html">Grammar<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B>SNF():<A HREF="../../../../Root/XML/Parser/Grammar/index.html">Grammar<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B>add(element:<A HREF="../../../../Root/XCore/Element/index.html">Element<A>):<A HREF="../../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B>addToClauses(v:<A HREF="../../../../Root/XCore/Element/index.html">Element<A>):<A HREF="../../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B>addToParents(v:<A HREF="../../../../Root/XCore/Element/index.html">Element<A>):<A HREF="../../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B>allClauses():<A HREF="../../../../Root/XML/Parser/Clause/index.html">Seq(Clause)<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B>cache():<A HREF="../../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B>checkForMissingClauses():<A HREF="../../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B>checkLL1():<A HREF="../../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B>clauseNamed(name:<A HREF="../../../../Root/XCore/String/index.html">String<A>):<A HREF="../../../../Root/XML/Parser/Clause/index.html">Clause<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B>clauses():<A HREF="../../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B>compile():<A HREF="../../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B>computeFirstAndFollowSets():<A HREF="../../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B>debug():<A HREF="../../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B>debug(indent:<A HREF="../../../../Root/XCore/Element/index.html">Element<A>,string:<A HREF="../../../../Root/XCore/Element/index.html">Element<A>,args:<A HREF="../../../../Root/XCore/Element/index.html">Element<A>):<A HREF="../../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B>deleteFromClauses(v:<A HREF="../../../../Root/XCore/Element/index.html">Element<A>):<A HREF="../../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B>deleteFromParents(v:<A HREF="../../../../Root/XCore/Element/index.html">Element<A>):<A HREF="../../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B>imports():<A HREF="../../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B>normalForm():<A HREF="../../../../Root/XML/Parser/Grammar/index.html">Grammar<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B>parents():<A HREF="../../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B>populatePPT():<A HREF="../../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B>pprint(out:<A HREF="../../../../Root/XCore/Element/index.html">Element<A>,indent:<A HREF="../../../../Root/XCore/Element/index.html">Element<A>):<A HREF="../../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B>pprintParseTable(out:<A HREF="../../../../Root/XCore/Element/index.html">Element<A>,width:<A HREF="../../../../Root/XCore/Element/index.html">Element<A>):<A HREF="../../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B>predict(clauseName:<A HREF="../../../../Root/XCore/String/index.html">String<A>,tag:<A HREF="../../../../Root/XCore/String/index.html">String<A>):<A HREF="../../../../Root/XML/Parser/Pattern/index.html">Seq(Pattern)<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B>removeClauseNamed(name:<A HREF="../../../../Root/XCore/String/index.html">String<A>):<A HREF="../../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B>setDebug(v:<A HREF="../../../../Root/XCore/Element/index.html">Element<A>):<A HREF="../../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B>terminals():<A HREF="../../../../Root/XCore/String/index.html">Set(String)<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B>toJava(pname:<A HREF="../../../../Root/XCore/String/index.html">String<A>,gname:<A HREF="../../../../Root/XCore/String/index.html">String<A>,out:<A HREF="../../../../Root/IO/OutputChannel/index.html">OutputChannel<A>):<A HREF="../../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B>toJavaFile(pname:<A HREF="../../../../Root/XCore/String/index.html">String<A>,root:<A HREF="../../../../Root/XCore/String/index.html">String<A>,gname:<A HREF="../../../../Root/XCore/String/index.html">String<A>):<A HREF="../../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B>toJavaFile(pname:<A HREF="../../../../Root/XCore/String/index.html">String<A>,root:<A HREF="../../../../Root/XCore/String/index.html">String<A>):<A HREF="../../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B>toXML(out:<A HREF="../../../../Root/IO/OutputChannel/index.html">OutputChannel<A>):<A HREF="../../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B>toXMLFile(file:<A HREF="../../../../Root/XCore/String/index.html">String<A>):<A HREF="../../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR>
<TD COLSPAN=2>
<FONT SIZE="-1">
<B>From</B> <A HREF="../../../../Root/XCore/NamedElement/index.html">NamedElement</A>: getNamedElement, href, name, path, pathSeq, repopulate, setName, toString. <BR><B>From</B> <A HREF="../../../../Root/XOCL/Syntax/index.html">Syntax</A>: compile, eval, lift, liftKeyArgs, liftValue, maxLocals, syntaxInit. <BR><B>From</B> <A HREF="../../../../Root/XCore/Contained/index.html">Contained</A>: addTo, allOwners, deleteRecursive, owner, removeFromOwner, setOwner. <BR><B>From</B> <A HREF="../../../../Root/XCore/Performable/index.html">Performable</A>: FV, compile, endLine, eval, line, maxLocals, pprint, pprint, pprint, setEndLine, setLine. <BR><B>From</B> <A HREF="../../../../Root/XCore/Object/index.html">Object</A>: addDaemon, addMultiDaemon, addPersistentDaemon, addStructuralFeature, allCompositeValues, allCompositeValuesAndSelf, allDaemonsWithId, allDaemonsWithTarget, compositeValues, daemonNamed, daemonWithId, daemonWithIdAndTarget, daemons, daemonsActive, destroyDaemon, edit, edit, fire, get, getProperties, getProperty, getStructuralFeatureNames, hasDaemonNamed, hasDaemonWithId, hasDaemonWithIdAndTarget, hasDaemonWithTarget, hasProperty, hasSlot, hasStructuralFeature, hotLoad, hotLoaded, init, initSlots, machineInit, removeDaemon, removeDaemonNamed, removeDaemonsWithId, removeDaemonsWithTarget, removeStructuralFeature, renameSlot, set, setDaemons, setDaemonsActive, setHotLoad, setProperty, slotDenied, slotMissing, slotMissing, slots. <BR><B>From</B> <A HREF="../../../../Root/XCore/Element/index.html">Element</A>: addTo, allHTMLEntries, allHTMLPackages, checkConstraints, copy, deleteRecursive, die, edit, equals, error, ferror, hashCode, init, init, isKindOf, isReallyKindOf, isTypeOf, lift, noOperationFound, oclIsKindOf, oclIsTypeOf, of, pprint, pprint, pprint, pprintln, print, println, removeDaemon, removeDaemon, save, save2, send, setOf, systemId, toHTML, toSnapshot, toSnapshot, toString, toType, writeHTML, writeHTML, writeHTMLAllEntries, writeHTMLAllPackages, writeHTMLIndex, writeHTMLOverview, writeXML, writeXMLFile, yield. <BR></FONT>
</TD>
</TR>
</TABLE>
<BR><HR><BR>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Grammar</B></FONT></TD>
</TR>
<TD><PRE>
@Grammar extends OCL::OCL.grammar 
    
      Grammar ::= name = Name parents = GrammarParents clauses = Clause* 'end' { 
      
        [| @Imports(imports)
             let grammar = <clauses->iterate(c g = Grammar(name) | g.add(c))>.imports := imports
             in <parents->iterate(parent exp = [| grammar |] | [| <exp>.addToParents(<parent>) |])>;
                grammar.compile()
             end
           end
        |]
        
      }.
      
      GrammarParents ::= 'extends' e = Exp es = (',' Exp)* { Seq{e | es} } | { Seq{} }.
      
      Clause ::= name = Name '::=' def = Disjunct '.' ! { Clause(name,Seq{def}) }.
      
      Disjunct ::= p = Conjunct qs = ('|' Disjunct)* { qs->iterate(q p = p | Or(p,q)) }.
      
      Conjunct ::= p = ClauseBind qs = (Conjunct)* { qs->iterate(q p = p | And(p,q)) }.
      
      ClauseBind ::= name = Name '=' p = Repeat { Bind(Seq{name},p) } | ClauseUpdate.
      
      ClauseUpdate ::= name = Name ':=' p = Repeat { Update(name,p) } | Repeat.
      
      Repeat ::= p = Opt ('*' { Star(p) } | '+' { Plus(p) } | '#' { Star(p,true) } | {p}).
      
      Opt ::= '[' p = ClauseAtom ']' { Opt(p) } | ClauseAtom.
      
      ClauseAtom ::= Element | Empty | Action | Call | Any | Text | Unordered | Repeats | '(' d = Disjunct ')' { Paren(d) }.
      
      Element ::= AtomicElement | CompositeElement.
      
      Empty ::= 'EMPTY' { Empty() }.
      
      Call ::= name = Name { Call(name) } .
      
      Action ::= '{' exp = Exp '}' { 
      
        if exp.isKindOf(Command)
        then Commands(Seq{exp})
        else Action(Seq{Exp(exp,exp.FV()->asSeq,null)}) 
        end
        
      }.
      
      Any ::= 'ANY' { Any() }.
      
      Text ::= 'TEXT' { Text() }.
      
      Unordered ::= 'Set' '{' UnorderedElements '}'.
      
      UnorderedElements ::= p = ClauseBind qs = (UnorderedElements)* { qs->iterate(q p = p | Unordered(p,q)) }.
      
      AtomicElement ::= '<' tag = Tag attributes = Attributes '/>' { Element(tag,attributes,Case(Seq{},Empty())) }.
      
      CompositeElement ::= '<' tag = Tag attributes = Attributes '>' children = Case '</' Tag '>' { Element(tag,attributes,children) }.
      
      Tag ::= Str | n = Name TagTail^(n).
      
      TagTail(n) ::= '.' m = Name n = { n + "." + m } TagTail^(n) | ':' m = Name n = { n + ":" + m } TagTail^(n) | { n }.
      
      Case ::= 'case' C = CaseClause* o = Otherwise 'end' { Case(C,o) } | o = Children { Case(Seq{},o) }.
      
      CaseClause ::= g = Guard 'do' p = Disjunct 'end' { CaseClause(g,p) }.
      
      Otherwise ::= 'else' Disjunct.
      
      Guard ::= b = BoolAnd bs = ('or' BoolAnd)* { bs->iterate(b x = b | BoolOr(x,b)) }.
      
      BoolAnd ::= b = BoolAtom bs = ('and' BoolAtom)* { bs->iterate(b x = b | BoolAnd(x,b)) }.
      
      BoolAtom ::= Equals | '(' b = Guard ')' { b } .
      
      Equals ::= e1 = GuardExp '=' e2 = GuardExp { Equals(e1,e2) }.
      
      GuardExp ::= Const | AttRef.
      
      Const ::= s = Str { Const(s) }.
      
      AttRef ::= n = Tag { AttRef(n) }.
      
      Children ::= Disjunct | { Empty() }.
      
      Attributes ::= atts = Attribute* { atts }.
      
      Attribute ::= var = Name tag = AttributeTag default = AttributeDefault { BindAtt(var,tag,default) }.
      
      AttributeTag ::= '=' Tag | { "" }.
      
      AttributeDefault ::= ':=' d = AttributeDefaultExp { Exp(d) } | { null }. 
      
      AttributeDefaultExp ::= e = DropExp { resolve(e) }.
      
      Repeats ::= 'Repeat' '{' C = RepeatClauses '}' { Repeat(C) }.
      
      RepeatClauses ::= r = RepeatClause rs = (';' RepeatClause)* { Seq{r | rs} }.
      
      RepeatClause ::= n = Name '=' d = Disjunct {
      
        RepeatClause(n,d)
        
      }.
      
    end
</PRE></TD>
</TABLE>
</HTML>
