<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML>
<HEAD>
<TITLE>
Grammar
</TITLE>
</HEAD>
<FONT SIZE="+2"><B>Grammar</B></FONT><BR><BR><HR>
<FONT SIZE="+1"><B>Overview</B></FONT><BR>
<P>
No Documentation Specified
<BR><HR>
<B>Owner</B>
<A HREF="../../../../Root/Parser/BNF/index.html">BNF</A>
<BR><HR>
<B>Parents</B>
<A HREF="../../../../Root/AbstractSyntax/KeepSource/index.html">KeepSource</A>
,<A HREF="../../../../Root/XCore/Performable/index.html">Performable</A>
,<A HREF="../../../../Root/XCore/NameSpace/index.html">NameSpace</A>
<BR><HR>
<B>Subclasses</B>
<BR><HR><BR>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Constructors</B></FONT></TD>
</TR>
</TABLE>
<BR><HR><BR>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=3><FONT SIZE="+2">
<B>Attributes</B></FONT></TD>
</TR>
<TR><TD><B>clauseCache</B></TD><TD><A HREF="../../../../Root/XCore/Table/index.html">Table<A></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B>clauses</B></TD><TD><A HREF="../../../../Root/Parser/BNF/Clause/index.html">Set(Clause)<A></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B>debug</B></TD><TD><A HREF="../../../../Root/XCore/Boolean/index.html">Boolean<A></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B>dynamics</B></TD><TD><A HREF="../../../../Root/XCore/Element/index.html">Seq(Element)<A></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B>parents</B></TD><TD><A HREF="../../../../Root/Parser/BNF/Grammar/index.html">Set(Grammar)<A></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B>startingSymbol</B></TD><TD><A HREF="../../../../Root/XCore/String/index.html">String<A></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B>terminals</B></TD><TD><A HREF="../../../../Root/XCore/String/index.html">Set(String)<A></TD><TD>No Documentation Specified</TD></TR>
<TR>
<TD COLSPAN=3>
<FONT SIZE="-1">
<B>From</B> <A HREF="../../../../Root/AbstractSyntax/KeepSource/index.html">KeepSource</A>: source. <BR><B>From</B> <A HREF="../../../../Root/XCore/Performable/index.html">Performable</A>: endLine, line. <BR><B>From</B> <A HREF="../../../../Root/XCore/NameSpace/index.html">NameSpace</A>: bindings, imports. <BR><B>From</B> <A HREF="../../../../Root/XCore/IndexedContainer/index.html">IndexedContainer</A>: contents. <BR><B>From</B> <A HREF="../../../../Root/XCore/NamedElement/index.html">NamedElement</A>: name. <BR><B>From</B> <A HREF="../../../../Root/XCore/DocumentedElement/index.html">DocumentedElement</A>: documentation. <BR><B>From</B> <A HREF="../../../../Root/XCore/Located/index.html">Located</A>: charEnd, charStart. <BR><B>From</B> <A HREF="../../../../Root/XCore/Contained/index.html">Contained</A>: owner. <BR></FONT>
</TD>
</TR>
</TABLE>
<BR><HR><BR>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="2" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Operations</B></FONT></TD>
</TR>
<TR><TD><B>FV():<A HREF="../../../../Root/XCore/String/index.html">Set(String)<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B>add(namedElement:<A HREF="../../../../Root/XCore/NamedElement/index.html">NamedElement<A>):<A HREF="../../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B>addClause(clause:<A HREF="../../../../Root/XCore/Element/index.html">Element<A>):<A HREF="../../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B>allClauses(name:<A HREF="../../../../Root/XCore/String/index.html">String<A>):<A HREF="../../../../Root/Parser/BNF/Clause/index.html">Set(Clause)<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B>allClauses():<A HREF="../../../../Root/Parser/BNF/Clause/index.html">Set(Clause)<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B>cacheTerminals():<A HREF="../../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B>calculateSets():<A HREF="../../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B>checkClauseOverlaps():<A HREF="../../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B>clauseNamed(name:<A HREF="../../../../Root/XCore/Element/index.html">Element<A>):<A HREF="../../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B>clean():<A HREF="../../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B>cleanClauses():<A HREF="../../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B>cnf():<A HREF="../../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B>compile():<A HREF="../../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B>compile(env:<A HREF="../../../../Root/XCore/Element/index.html">Element<A>,frame:<A HREF="../../../../Root/XCore/Element/index.html">Element<A>,isLast:<A HREF="../../../../Root/XCore/Element/index.html">Element<A>,saveSource:<A HREF="../../../../Root/XCore/Element/index.html">Element<A>):<A HREF="../../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B>dprint():<A HREF="../../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B>eval(target:<A HREF="../../../../Root/XCore/Element/index.html">Element<A>,env:<A HREF="../../../../Root/XCore/Element/index.html">Element<A>,imports:<A HREF="../../../../Root/XCore/Element/index.html">Element<A>):<A HREF="../../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B>inheritClauses():<A HREF="../../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B>inheritedClauses(name:<A HREF="../../../../Root/XCore/String/index.html">String<A>):<A HREF="../../../../Root/Parser/BNF/Clause/index.html">Set(Clause)<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B>inheritedClauses():<A HREF="../../../../Root/Parser/BNF/Clause/index.html">Set(Clause)<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B>inheritedTerminals():<A HREF="../../../../Root/XCore/String/index.html">Set(String)<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B>init(args:<A HREF="../../../../Root/XCore/Element/index.html">Element<A>):<A HREF="../../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B>last(name:<A HREF="../../../../Root/XCore/String/index.html">String<A>):<A HREF="../../../../Root/XCore/String/index.html">Set(String)<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B>last():<A HREF="../../../../Root/XCore/String/index.html">Set(String)<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B>lift():<A HREF="../../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B>liftOrs():<A HREF="../../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B>localClauses(name:<A HREF="../../../../Root/XCore/String/index.html">String<A>):<A HREF="../../../../Root/Parser/BNF/Clause/index.html">Set(Clause)<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B>localTerminals():<A HREF="../../../../Root/XCore/String/index.html">Set(String)<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B>maxLocals():<A HREF="../../../../Root/XCore/Integer/index.html">Integer<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B>newClauseName(prefix:<A HREF="../../../../Root/XCore/Element/index.html">Element<A>):<A HREF="../../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B>parseFile(file:<A HREF="../../../../Root/XCore/Element/index.html">Element<A>,startNT:<A HREF="../../../../Root/XCore/Element/index.html">Element<A>,imports:<A HREF="../../../../Root/XCore/Element/index.html">Element<A>,tokenizer:<A HREF="../../../../Root/XCore/Element/index.html">Element<A>):<A HREF="../../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B>parseFile(file:<A HREF="../../../../Root/XCore/Element/index.html">Element<A>,startNT:<A HREF="../../../../Root/XCore/Element/index.html">Element<A>,imports:<A HREF="../../../../Root/XCore/Element/index.html">Element<A>):<A HREF="../../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B>parseFile(name:<A HREF="../../../../Root/XCore/String/index.html">String<A>):<A HREF="../../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B>parseString(s:<A HREF="../../../../Root/XCore/String/index.html">String<A>,startNT:<A HREF="../../../../Root/XCore/String/index.html">String<A>,imports:<A HREF="../../../../Root/XCore/NameSpace/index.html">Seq(NameSpace)<A>):<A HREF="../../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B>parseString(s:<A HREF="../../../../Root/XCore/String/index.html">String<A>):<A HREF="../../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B>parseString(s:<A HREF="../../../../Root/XCore/String/index.html">String<A>,startNT:<A HREF="../../../../Root/XCore/String/index.html">String<A>,args:<A HREF="../../../../Root/XCore/Element/index.html">Seq(Element)<A>,imports:<A HREF="../../../../Root/XCore/NameSpace/index.html">Seq(NameSpace)<A>):<A HREF="../../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B>pprint(indent:<A HREF="../../../../Root/XCore/Element/index.html">Element<A>):<A HREF="../../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B>pprint(outputChannel:<A HREF="../../../../Root/XCore/Element/index.html">Element<A>,indent:<A HREF="../../../../Root/XCore/Element/index.html">Element<A>):<A HREF="../../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B>predict():<A HREF="../../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B>terminals():<A HREF="../../../../Root/XCore/String/index.html">Set(String)<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B>toString():<A HREF="../../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR><TD><B>transform():<A HREF="../../../../Root/XCore/Element/index.html">Element<A></B></TD><TD>No Documentation Specified</TD></TR>
<TR>
<TD COLSPAN=2>
<FONT SIZE="-1">
<B>From</B> <A HREF="../../../../Root/XCore/Performable/index.html">Performable</A>: FV, compile, endLine, eval, line, maxLocals, pprint, pprint, pprint, setEndLine, setLine. <BR><B>From</B> <A HREF="../../../../Root/XCore/NameSpace/index.html">NameSpace</A>: add, addBinding, addImport, allHTMLEntries, allHTMLPackages, allImports, allNames, define, getContents, getDiagram, getDiagram, getElement, getInstantiableClasses, hasBinding, hasElement, importedFrom, imports, init, init, initBindings, lift, lookupPath, nameChanged, names, newName, putElement, redefine, remove, removeBinding, removeImport, resolveNameClash, syntaxClasses, toHTML, toHTMLDoc, toType, writeEcore. <BR><B>From</B> <A HREF="../../../../Root/XCore/IndexedContainer/index.html">IndexedContainer</A>: add, add, addContentDaemon, contentDaemons, contents, index, indices, init, initContents, remove, removeContentDaemon. <BR><B>From</B> <A HREF="../../../../Root/XCore/NamedElement/index.html">NamedElement</A>: getNamedElement, href, name, path, pathSeq, repopulate, setName, toString. <BR><B>From</B> <A HREF="../../../../Root/XCore/DocumentedElement/index.html">DocumentedElement</A>: doc, ensureDoc, setDoc. <BR><B>From</B> <A HREF="../../../../Root/XCore/Container/index.html">Container</A>: add, addContentDaemon, allContents, allContentsOf, allContentsThat, checkConstraints, checkConstraints, contentDaemons, contents, contentsOf, contentsThat, deleteRecursive, includes, init, initContents, remove, removeContentDaemon, traceAll, untraceAll. <BR><B>From</B> <A HREF="../../../../Root/XCore/Contained/index.html">Contained</A>: addTo, allOwners, deleteRecursive, owner, removeFromOwner, setOwner. <BR><B>From</B> <A HREF="../../../../Root/XCore/Object/index.html">Object</A>: addDaemon, addMultiDaemon, addPersistentDaemon, addStructuralFeature, allCompositeValues, allCompositeValuesAndSelf, allDaemonsWithId, allDaemonsWithTarget, compositeValues, daemonNamed, daemonWithId, daemonWithIdAndTarget, daemons, daemonsActive, destroyDaemon, edit, fire, get, getProperties, getProperty, getStructuralFeatureNames, hasDaemonNamed, hasDaemonWithId, hasDaemonWithIdAndTarget, hasDaemonWithTarget, hasProperty, hasSlot, hasStructuralFeature, hotLoad, hotLoaded, init, initSlots, machineInit, removeDaemon, removeDaemonNamed, removeDaemonsWithId, removeDaemonsWithTarget, removeStructuralFeature, renameSlot, set, setDaemons, setDaemonsActive, setHotLoad, setProperty, slotDenied, slotMissing, slotMissing, slots. <BR><B>From</B> <A HREF="../../../../Root/XCore/Element/index.html">Element</A>: addTo, allHTMLEntries, allHTMLPackages, checkConstraints, copy, deleteRecursive, die, edit, equals, error, ferror, hashCode, init, init, isKindOf, isReallyKindOf, isTypeOf, lift, noOperationFound, oclIsKindOf, oclIsTypeOf, of, pprint, pprint, pprint, pprintln, print, println, removeDaemon, removeDaemon, save, save2, send, setOf, systemId, toHTML, toSnapshot, toSnapshot, toString, toType, writeHTML, writeHTML, writeHTMLAllEntries, writeHTMLAllPackages, writeHTMLIndex, writeHTMLOverview, writeXML, writeXMLFile, yield. <BR></FONT>
</TD>
</TR>
</TABLE>
<BR><HR><BR>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Grammar</B></FONT></TD>
</TR>
<TD><PRE>
@Grammar extends OCL::OCL.grammar
 
    XBNF_Action ::= 
    
      // An action is either an expression in { and } 
      // which synthesizes a value or is a predicate that
      // must be true for the parse to proceed...
      
      '{' exp = <<Exp>> '}' 
      { PreAction(exp) } 
    | '?' boolExp = <<Exp>>
      { PrePredicate(boolExp) }.
    
    XBNF_Atom ::=  
    
      // An atom is the basic unit of a clause...
      
      <<XBNF_Action>>    
    | <<XBNF_Literal>>  
    | <<XBNF_Call>>    
    | <<XBNF_Not>>      
    | '(' <<XBNF_Disjunction>> ')'
    | '<<' d= <<XBNF_Disjunction>> '>>' { And(PushChar(),And(d,PopChar())) }.
  
    XBNF_Binding ::= 
    
      // A clause binding performs a grammar action and
      // associates the value produced with a named 
      // local...
      
      name = Name '=' atom = <<XBNF_Sequence>> b = { Bind(name) } { 
        And(atom,b) 
      }.
    
    XBNF_Call ::= 
    
      // Call a clause. The arguments are optional...
      
      name = Name args = XBNF_CallArgs { Call(name,args) }.
      
    XBNF_CallArgs ::= 
    
      // Arguments supplied to a clause are optional.
      // The args must be preceded by a ^ to distinguish
      // the args from a pair of calls with 0 args...
    
      '^' '(' n = Name ns = (',' Name)* ')' { Seq{n|ns} } 
    | { Seq{} }.
  
    XBNF_Clause ::= 
    
      name = Name args = XBNF_ClauseArgs '::=' body = <<XBNF_Disjunction>> '.' 
      { Clause(name,args,body) }. 
  
    XBNF_ClauseArgs ::= 
    
      '(' n = Name ns = (',' Name)* ')' { Seq{n|ns} } 
    | { Seq{} }.
    
    XBNF_Conjunction ::= 
    
      // Conjunction is just a sequence of 1 or more
      // clause elements...
    
      elements = (<<XBNF_Element>>)+ { 
       elements->tail->iterate(e conj = elements->head | 
         And(conj,e)) 
    }. 
  
    XBNF_Disjunction ::= 
    
      // A disjunction is a sequence of elements
      // separated by | ...
    
      element = <<XBNF_Conjunction>> (
        '|' rest = <<XBNF_Disjunction>> { Or(element,rest) } | { element }).
   
    XBNF_Element ::= 
    
      <<XBNF_Optional>>    
    | <<XBNF_Binding>>  
    | <<XBNF_Sequence>>.
  
    Grammar ::=   
      parents = XBNF_GrammarParents
      imports = XBNF_GrammarImports
      clauses = (<<XBNF_Clause>>)* 
      'end' 
      { Grammar(parents,clauses->asSet,"",imports) }.
   
    XBNF_GrammarImports ::=
    
      // The imports of a grammar affect the grammars that are
      // available via @... 
    
      'import' class = <<Exp>> classes = (',' <<Exp>>)* { Seq{class | classes} } 
    | { Seq{} }.
   
    XBNF_GrammarParents ::= 
    
      // A grammar may inherit from 0 or more parent grammars.
      // The parent clauses are added to the child...
    
      'extends' parent = <<Exp>> parents = (',' <<Exp>>)* { parents->asSet->including(parent) } 
    | { Set{} }.

    XBNF_Literal ::=  
    
      // The following literals are built-in non-terminals of a
      // grammar. The action uses getElement to reference the
      // classes (and therefore the constructors) because a grammar
      // cannot reference a variable with the same name as a terminal
      // in an action...
      
      // Get the next character...
    
      'Char'       { (Parser::BNF.getElement("Char"))() }    
      
      // Get the next line...
       
    | 'Line'       { (Parser::BNF.getElement("Line"))() }     
    
      // Get a string...
      
    | 'Str'        { (Parser::BNF.getElement("Str"))() }      
    
      // Get a terminal (in ' and ')...
      
    | 'Terminal'   { (Parser::BNF.getElement("Term"))() }     
    
      // Return the current token...
      
    | 'Token'      { (Parser::BNF.getElement("Tok"))() } 
    
      // Get an integer...
           
    | 'Int'        { (Parser::BNF.getElement("Int"))() }      
    
      // Get a float...
      
    | 'Float'      { (Parser::BNF.getElement("Float"))() }    
    
      // Get a name...
      
    | 'Name'       { (Parser::BNF.getElement("Name"))() } 
    
      // Expect end-of-file...
          
    | 'EOF'        { (Parser::BNF.getElement("EOF"))() }      
    
      // Throw away all choice points created since starting
      // the current clause...
      
    | '!'          { (Parser::BNF.getElement("Cut"))() }   
    
      // Dispatch to the grammar on the most recently
      // synthesized value which should be a sequence of
      // names the represent a path to a classifier with
      // respect to the currently imported name-spaces...
         
    | '@'          { (Parser::BNF.getElement("At"))() }      
    
      // Add a name-space to the currently imported 
      // name-spaces...
       
    | 'ImportAt'   { (Parser::BNF.getElement("ImportAt"))() } 
    
      // Get the current state of the parsing engine...
      
    | 'pState'     { (Parser::BNF.getElement("PState"))() }   
    
      // Get the current line position...
      
    | 'LinePos'    { (Parser::BNF.getElement("LinePos"))() } 
    
      // Define a new terminal in the form NewToken(NAME,ID)...
      
    | <<XBNF_NewToken>>                                
    
      // Get a terminal name...
                      
    | terminal = Terminal { (Parser::BNF.getElement("Terminal"))(terminal) }.
    
    XBNF_NewToken ::= 
    
      // A new token is defined as a name and an integer id.
      // The tokenizer used to parse the grammar is responsible
      // for returning a token with the type set to the id...
    
      'NewToken' '(' n = Name ',' t = Int ')' {
        (Parser::BNF.getElement("NewToken"))(n,t) 
    }.
       
    XBNF_Not ::= 
    
      // Deprecated...
    
      'Not' '(' parser = XBNF_Sequence ')' { (Parser::BNF.getElement("Not"))(parser) }.

    XBNF_Optional ::= 
    
      // An optional clause element is tried and ignored if it fails...
      
      '[' opt = <<XBNF_Disjunction>> ']'
      { Opt(opt) }.
  
    XBNF_Path ::= name = Name names = ('::' Name)* { Seq{name | names} }.
    
    XBNF_TypeCheck ::=
    
      // An element that checks the type of the synthesized value...
    
      element = <<XBNF_Atom>> (':' type = XBNF_Path { And(element,TypeCheck(type)) } 
    | { element }).
  
    XBNF_Sequence ::=
    
      // An element an be followed by a * or a + for 0
      // or more and 1 or more repetitions...
    
      element = XBNF_TypeCheck ( 
        '*' { StarCons(element) } 
      | '+' { PlusCons(element) } 
      | { element }
      ).
    
end
</PRE></TD>
</TABLE>
</HTML>
